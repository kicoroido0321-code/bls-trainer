<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>BLS Rhythm Trainer – アンパンマンのマーチ v1.8 (fixsync, BPM96.05, GO+3s)</title>
<style>
  body{margin:0;background:#faefdb;font-family:"Segoe UI","Rounded Mplus 1c",sans-serif;text-align:center;overflow:hidden}
  h2{margin-top:10px;color:#d85b7b}
  canvas{background:#faefdb;border-radius:8px;margin-top:10px}
  .controls{margin:10px 0}
  #judge{position:absolute;top:45%;left:50%;transform:translate(-50%,-50%);
    font-size:48px;font-weight:800;color:#fff;text-shadow:0 0 10px #0008;opacity:0;transition:opacity .3s;pointer-events:none}
  #result{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
    background:rgba(255,246,236,.95);border:3px solid #f5a3a3;border-radius:16px;padding:22px 40px;
    color:#d85b7b;font-weight:700;font-size:24px;box-shadow:0 0 12px rgba(255,200,200,.5);opacity:0;transition:opacity .8s}
  #count{position:absolute;top:38%;left:50%;transform:translate(-50%,-50%);
    font-size:96px;font-weight:900;color:#d85b7b;text-shadow:0 6px 18px rgba(216,91,123,.35);opacity:0;transition:opacity .2s}
  #hint{font-size:13px;color:#666;margin:6px 0 10px}
</style>
</head>
<body>
<h2>💖 BLS Rhythm Trainer – アンパンマンのマーチ（v1.8 fixsync）</h2>

<div class="controls">
  <button id="start">▶ 開始</button>
  <button id="stop">■ 停止</button>
  <button id="reset">↻ リセット</button>
  <span id="sound" style="font-size:13px;color:#444">🔇 音未確認</span>
</div>

<div style="position:relative;display:inline-block;">
  <canvas id="game" width="1000" height="600"></canvas>
  <div id="judge">Perfect!</div>
  <div id="result"></div>
  <div id="count">3</div>
</div>

<p id="hint">
赤＝胸骨圧迫（単発）／青＝人工呼吸（長押し2拍）<br>
右→左に流れます。左のマネキンの口・胸の円が判定ライン。<br>
<b>「GO!」の3秒後に最初の赤ノーツが判定円に到達</b>します（BPM 96.05）。
</p>

<script>
(()=>{

// ===== Canvas / layout =====
const W=1000,H=600;
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');

const hitX=190;                 // 判定円X
const mouthY=H*0.32, chestY=H*0.61;
const spawnX=W+100;             // 右端の外側から出現

// 背景マネキン（模型の画像ファイル名はプロジェクトに合わせて置いてね）
const mannequin=new Image();
mannequin.src='./AA3BFA6F-7DB2-44A5-BED7-E7BC31A224EF.png';
let imgReady=false; mannequin.onload=()=>imgReady=true;

// ===== Audio (click) =====
let AC, clickBuf, running=false, goTime=null;
async function ensureAudio(){
  if(!AC) AC=new (window.AudioContext||window.webkitAudioContext)();
  await AC.resume();
  if(!clickBuf){
    const len=AC.sampleRate*0.04;
    clickBuf=AC.createBuffer(1,len,AC.sampleRate);
    const d=clickBuf.getChannelData(0);
    for(let i=0;i<len;i++){
      d[i]=Math.sin(2*Math.PI*1000*i/AC.sampleRate)*Math.exp(-i/(len/8));
    }
  }
  document.getElementById('sound').textContent='🔊 音OK';
}
function click(){if(!AC||!clickBuf)return; const s=AC.createBufferSource(); s.buffer=clickBuf; s.connect(AC.destination); s.start();}

// ===== Score / UI =====
const judgeEl=document.getElementById('judge');
const resultEl=document.getElementById('result');
const countEl=document.getElementById('count');
let perfect=0,good=0,miss=0;

function showJudge(t,c){judgeEl.textContent=t;judgeEl.style.color=c;judgeEl.style.opacity=1;setTimeout(()=>judgeEl.style.opacity=0,500);}

// ===== Chart（保存版ロジック） =====
// テンポは 96.05 BPM（1拍 ≒ 0.62474s）
const BPM=96.05;
const SPB=60/BPM;

// 成人30:2（圧迫30拍 → 呼吸×2（各1.2拍ホールド＋0.7拍間））を繰り返し
// Paprika保存版のタイム構造を踏襲（offsetは「到達基準の時刻差（秒）」）
let chartTemplate=[];
(function build(){
  const hold=1.2*SPB;
  let t=0;
  const cycles=6; // 1番分として十分な長さ（必要なら調整OK）
  for(let c=0;c<cycles;c++){
    for(let i=0;i<30;i++){ chartTemplate.push({type:'comp',offset:t,y:chestY}); t+=SPB; }
    chartTemplate.push({type:'breath',offset:t+0.7*SPB,hold:hold,y:mouthY}); t+=1.2*SPB+0.7*SPB;
    chartTemplate.push({type:'breath',offset:t+0.7*SPB,hold:hold,y:mouthY}); t+=1.2*SPB+0.7*SPB;
  }
})();

// ===== 判定と描画の完全同期設定 =====
// 「描画式」と「判定用のtime」を同じ基準で作る：
//   x = hitX + (n.time - now) * speed
// とし、n.time は「ノーツが判定円に到達する絶対時刻」。
// NOTE_TRAVEL は「spawnX（右端外）→ hitX までに要する秒数」。
const ARRIVE_FIRST = 3.0;   // GO→3秒後に最初の赤が到達
const NOTE_TRAVEL  = 3.0;   // 移動時間（保存版の気持ちよさと視認性を両立）
const speed        = (spawnX - hitX) / NOTE_TRAVEL; // px/s

let chart=[]; // 実時間展開後の譜面
const HIT={perfect:0.10, good:0.18}; // 判定幅（秒）

// 判定（圧迫：単発）
function judgeTap(y,time){
  for(const n of chart){
    if(n.hit || Math.abs(n.y-y)>6) continue;
    if(n.type!=='comp') continue;
    const diff=Math.abs(time-n.time);
    if(diff<HIT.perfect){ n.hit='perfect'; return 'perfect'; }
    if(diff<HIT.good){ n.hit='good';     return 'good'; }
  }
  return 'miss';
}

// 呼吸（長押し：開始時刻のみ合わせ、離した長さで判定）
let holdActive=null;
function tryStartHold(y,time){
  for(const n of chart){
    if(n.hit || n.type!=='breath' || Math.abs(n.y-y)>6) continue;
    if(Math.abs(time-n.time) < HIT.good){
      holdActive={note:n,startTime:time};
      return 'start';
    }
  }
  return 'fail';
}
function finishHold(time){
  if(!holdActive) return 'miss';
  const n=holdActive.note;
  if(n.hit){ holdActive=null; return 'miss'; }
  const held=time-holdActive.startTime;
  const expect=n.hold||0;
  const err=Math.abs(held-expect);
  let res;
  if(err<=0.15) res='perfect';
  else if(err<=0.30) res='good';
  else res='miss';
  n.hit=res; holdActive=null; return res;
}

// 入力
canvas.addEventListener('pointerdown', async e=>{
  await ensureAudio(); click();
  if(!running) return;
  const r=canvas.getBoundingClientRect();
  const y=(e.clientY-r.top)*(H/r.height);
  const lane = Math.abs(y-mouthY)<40 ? mouthY : (Math.abs(y-chestY)<40 ? chestY : null);
  if(lane==null) return;
  const t=AC.currentTime;
  if(lane===chestY){
    const res=judgeTap(lane,t);
    if(res==='perfect'){ perfect++; showJudge('Perfect!','#ff8ccf'); }
    else if(res==='good'){ good++; showJudge('Good!','#ffd93b'); }
    else { miss++; showJudge('Miss!','#ff4b4b'); }
  }else{
    const s=tryStartHold(lane,t);
    if(s==='start'){ showJudge('Hold','#8cdcff'); }
    else { miss++; showJudge('Miss!','#ff4b4b'); }
  }
});
canvas.addEventListener('pointerup', e=>{
  if(!running) return;
  const t=AC.currentTime;
  if(holdActive){
    const r=finishHold(t);
    if(r==='perfect'){ perfect++; showJudge('Perfect!','#8cdcff'); }
    else if(r==='good'){ good++; showJudge('Good!','#ffd93b'); }
    else { miss++; showJudge('Miss!','#ff4b4b'); }
  }
});

// 描画（保存版と同式）
function draw(now){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='#faefdb'; ctx.fillRect(0,0,W,H);

  if(imgReady){
    const ratio=mannequin.width/mannequin.height;
    const th=H, tw=th*ratio;
    ctx.drawImage(mannequin,0,0,tw,th);
  }

  // レーン
  ctx.fillStyle='rgba(150,180,255,0.25)'; ctx.fillRect(0,mouthY-20,W,40);
  ctx.fillStyle='rgba(255,180,180,0.25)'; ctx.fillRect(0,chestY-20,W,40);

  // 判定円
  ctx.lineWidth=4;
  ctx.strokeStyle='#1877ff'; ctx.beginPath(); ctx.arc(hitX,mouthY,30,0,Math.PI*2); ctx.stroke();
  ctx.strokeStyle='#ff4b4b'; ctx.beginPath(); ctx.arc(hitX,chestY,35,0,Math.PI*2); ctx.stroke();

  for(const n of chart){
    // ★ 判定基準と同じ time を使って描画座標を決定
    const x = hitX + (n.time - now) * speed;  // 右→左（now < n.time なら hitXより右）
    if(x < -140 || x > spawnX+40) continue;

    if(n.type==='comp'){
      ctx.fillStyle='#ff4b4b';
      ctx.beginPath(); ctx.arc(x,n.y,20,0,Math.PI*2); ctx.fill();
    }else{
      // 長押し終点の見た目も同じ式で
      const xEnd = hitX + ((n.time + n.hold) - now) * speed;
      ctx.fillStyle='#1877ff';
      ctx.fillRect(Math.min(x,xEnd), n.y-10, Math.abs(xEnd-x), 20);
      ctx.beginPath(); ctx.arc(x,n.y,10,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(xEnd,n.y,10,0,Math.PI*2); ctx.fill();
    }
  }
}

let lastNoteTime=0;
function loop(){
  const now = AC ? AC.currentTime : performance.now()/1000;
  draw(now);
  if(running){
    if(now > lastNoteTime + 2.0){ running=false; showResult(); return; }
    requestAnimationFrame(loop);
  }
}

function showResult(){
  const total=chart.length;
  const score=Math.round((perfect*3 + good*1) / (total*3) * 100);
  resultEl.innerHTML = `💖 SCORE ${score}点！<br>Perfect: ${perfect}　Good: ${good}　Miss: ${miss}`;
  resultEl.style.opacity=1;
}

// ===== Start / Countdown =====
function countdown(onGo){
  const seq=['3','2','1','GO!']; let i=0;
  countEl.style.opacity=1; countEl.textContent=seq[i++];
  const timer=setInterval(()=>{
    if(i<seq.length){ countEl.textContent=seq[i++]; }
    else{ clearInterval(timer); setTimeout(()=>countEl.style.opacity=0,500); onGo(); }
  },1000);
}

document.getElementById('start').onclick=async()=>{
  await ensureAudio(); click();
  perfect=good=miss=0; resultEl.style.opacity=0; running=true;

  countdown(()=>{
    goTime = AC.currentTime;

    // ★ 最初の赤ノーツが「GO+3秒」で判定円到達
    // 判定用 time は「到達時刻」。出現は (time - NOTE_TRAVEL) から描画上で表現される。
    const arriveBase = goTime + ARRIVE_FIRST; // 最初の到達基準（GO+3s）

    chart = chartTemplate.map(n=>({
      ...n,
      time: arriveBase + n.offset, // ← 各ノーツが判定円に重なる絶対時刻
      hold: n.hold||0,
      y: n.y,
      hit: false
    }));

    lastNoteTime = chart.reduce((mx,n)=>Math.max(mx, n.time + (n.hold||0)), 0);
    loop();
  });
};

document.getElementById('stop').onclick=()=>{ running=false; showResult(); };
document.getElementById('reset').onclick=()=>window.location.reload();

})();
</script>
</body>
</html>
