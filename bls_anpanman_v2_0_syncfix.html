<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>BLS Rhythm Trainer – アンパンマンのマーチ v2.0 (BPM96.05・GO後3秒到達・保存版スピード)</title>
<style>
  body{margin:0;background:#faefdb;font-family:"Segoe UI","Rounded Mplus 1c",sans-serif;text-align:center;overflow:hidden}
  h2{margin-top:10px;color:#d85b7b}
  canvas{background:#faefdb;border-radius:8px;margin-top:10px}
  .controls{margin:10px 0}
  #judge{position:absolute;top:45%;left:50%;transform:translate(-50%,-50%);
    font-size:48px;font-weight:bold;color:white;text-shadow:0 0 10px black;
    opacity:0;transition:opacity .3s ease;pointer-events:none}
  #resultPanel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
    background:rgba(255,246,236,.9);border:3px solid #f5a3a3;border-radius:16px;
    padding:24px 48px;text-align:center;color:#d85b7b;font-weight:bold;font-size:26px;
    opacity:0;transition:opacity 1s ease;pointer-events:none;box-shadow:0 0 12px rgba(255,200,200,.5)}
  #countdown{position:absolute;top:38%;left:50%;transform:translate(-50%,-50%);
    font-size:96px;font-weight:800;color:#d85b7b;text-shadow:0 4px 16px rgba(216,91,123,.35);
    opacity:0;transition:opacity .2s ease;pointer-events:none}
  #hint{font-size:13px;color:#666;margin-top:6px}
</style>
</head>
<body>
<h2>💖 BLS Rhythm Trainer – アンパンマンのマーチ (BPM96.05・GO後3秒到達・保存版スピード)</h2>

<div class="controls">
  <button id="start">▶ 開始</button>
  <button id="stop">■ 停止</button>
  <button id="reset">↻ リセット</button>
  <span id="sound" style="font-size:13px;color:#444;">🔇 音未確認</span>
</div>

<div style="position:relative;display:inline-block">
  <canvas id="game" width="1000" height="600"></canvas>
  <div id="judge">Perfect!</div>
  <div id="resultPanel"></div>
  <div id="countdown">3</div>
</div>

<p id="hint">
外部端末で「アンパンマンのマーチ」を再生してください。<br>
カウントダウン「GO!」と同時に曲を流し、<br>
<b>GOから3秒後</b>に最初のノーツが判定円に到達します。<br>
（1番終了＝約1分10秒）
</p>

<script>
(()=>{
  // ===== 基本レイアウト =====
  const W=1000,H=600;
  const canvas=document.getElementById("game");
  const ctx=canvas.getContext("2d");
  const judgeEl=document.getElementById("judge");
  const resultPanel=document.getElementById("resultPanel");
  const countdownEl=document.getElementById("countdown");

  // 模型画像（あなたのリポジトリのファイル名に合わせてね）
  const mannequin=new Image();
  mannequin.src="./AA3BFA6F-7DB2-44A5-BED7-E7BC31A224EF.png";
  let imgReady=false; mannequin.onload=()=>imgReady=true;

  // 判定座標
  const mouthY=H*0.32, chestY=H*0.61, hitX=190;

  // ===== Audio（クリック） =====
  let AC, clickBuf, running=false;
  async function ensureAudio(){
    if(!AC) AC=new (window.AudioContext||window.webkitAudioContext)();
    await AC.resume();
    if(!clickBuf){
      const len=AC.sampleRate*0.04;
      clickBuf=AC.createBuffer(1,len,AC.sampleRate);
      const d=clickBuf.getChannelData(0);
      for(let i=0;i<len;i++){
        d[i]=Math.sin(2*Math.PI*1000*i/AC.sampleRate)*Math.exp(-i/(len/8));
      }
    }
    document.getElementById("sound").textContent="🔊 音OK";
  }
  function click(){
    if(!AC||!clickBuf) return;
    const s=AC.createBufferSource();
    s.buffer=clickBuf;
    s.connect(AC.destination);
    s.start();
  }

  // ===== スコア・演出 =====
  let perfect=0, good=0, miss=0;
  function flashJudge(t,c){
    judgeEl.textContent=t;
    judgeEl.style.color=c;
    judgeEl.style.opacity=1;
    setTimeout(()=>judgeEl.style.opacity=0,500);
  }
  function spawnHeart(x,y){ hearts.push({x,y,vy:-1,alpha:1}); }
  let hearts=[];
  function spawnFlash(x,y,c){ flashes.push({x,y,life:1,color:c}); }
  let flashes=[];

  // ===== テンポと保存版スピード =====
  const bpm=96.05;
  const spb=60/bpm;        // 1拍
  const lead=4*spb;        // ★「保存版」で使っていた見やすい移動時間（ノーツが右端→判定円までに要する秒数）

  // ===== ここが重要！GO→3秒後に到達させる式 =====
  const ARRIVE_AT = 3;          // GOから到達まで3秒
  // ★ v1系でズレが出た原因は「ARRIVE_AT - lead」を使っていたこと。
  //    到達時刻そのもの（n.time）を GO+ARRIVE_AT に揃えるのが正解。
  //    すると描画側の x=hitX+(n.time-now)*speed により、
  //    now = n.time - lead の時に x が右端になって自然出現する。
  const appearDelay = ARRIVE_AT;    // ← ここを lead で減算しないのがポイント
  const STOP_AT = 71;

  // ===== 譜面テンプレート（赤30 → 青×2（各1拍ホールド＋1拍インターバル）） =====
  let chartTemplate=[];
  (function buildTemplate(){
    let t=0;
    const hold=1*spb;      // 呼吸は1拍ホールド
    const cycles=6;        // 成人30:2 を6セット（1番相当）
    for(let c=0;c<cycles;c++){
      for(let i=0;i<30;i++){ chartTemplate.push({type:"comp",offset:t,y:chestY}); t+=spb; }
      chartTemplate.push({type:"breath",offset:t,hold:hold,y:mouthY}); t+=hold + spb; // 1拍ホールド＋1拍の間
      chartTemplate.push({type:"breath",offset:t,hold:hold,y:mouthY}); t+=hold + spb;
    }
  })();

  // ===== 判定 =====
  let chart=[];
  const HIT={perfect:0.10, good:0.18}; // 秒
  let holdActive=null;

  function judgeTapForComp(y,time){
    for(const n of chart){
      if(n.hit || n.type!=="comp" || Math.abs(n.y-y)>6) continue;
      const diff=Math.abs(time-n.time);
      if(diff<HIT.perfect){ n.hit="perfect"; return "perfect"; }
      if(diff<HIT.good){    n.hit="good";    return "good"; }
    }
    return "miss";
  }
  function tryStartHold(y,time){
    for(const n of chart){
      if(n.hit || n.type!=="breath" || Math.abs(n.y-y)>6) continue;
      if(Math.abs(time-n.time) < HIT.good){
        holdActive={note:n,startTime:time}; return "start";
      }
    }
    return "fail";
  }
  function finishHold(time){
    if(!holdActive) return "miss";
    const n=holdActive.note;
    if(n.hit){ holdActive=null; return "miss"; }
    const held=time-holdActive.startTime;
    const expect=n.hold||0;
    const err=Math.abs(held-expect);
    const res = (err<=0.15) ? "perfect" : (err<=0.30) ? "good" : "miss";
    n.hit=res; holdActive=null; return res;
  }

  canvas.addEventListener("pointerdown", async e=>{
    await ensureAudio(); click();
    if(!running) return;
    const rect=canvas.getBoundingClientRect();
    const y=(e.clientY-rect.top)*(H/rect.height);
    const lane = Math.abs(y-mouthY)<40 ? mouthY : (Math.abs(y-chestY)<40 ? chestY : null);
    if(!lane) return;
    const t=AC.currentTime;
    if(lane===chestY){
      const r=judgeTapForComp(lane,t);
      if(r==="perfect"){ perfect++; flashJudge("Perfect!","#ff8ccf"); spawnHeart(hitX,lane-20); spawnFlash(hitX,lane,"#ffbcd9"); }
      else if(r==="good"){ good++;  flashJudge("Good!","#ffd93b");      spawnFlash(hitX,lane,"#fff3a3"); }
      else { miss++; flashJudge("Miss!","#ff4b4b"); }
    }else{
      const s=tryStartHold(lane,t);
      if(s==="start"){ flashJudge("Hold","#8cdcff"); spawnFlash(hitX,lane,"#cfe4ff"); }
      else { miss++; flashJudge("Miss!","#ff4b4b"); }
    }
  });
  canvas.addEventListener("pointerup", e=>{
    if(!running) return;
    const t=AC.currentTime;
    if(holdActive){
      const r=finishHold(t);
      const yy = holdActive?.note?.y ?? mouthY;
      if(r==="perfect"){ perfect++; flashJudge("Perfect!","#8cdcff"); spawnHeart(hitX,yy-20); }
      else if(r==="good"){ good++; flashJudge("Good!","#ffd93b"); }
      else { miss++; flashJudge("Miss!","#ff4b4b"); }
    }
  });

  // ===== 描画（保存版と同式：右→左） =====
  function draw(now){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#faefdb"; ctx.fillRect(0,0,W,H);

    if(imgReady){
      const ratio=mannequin.width/mannequin.height;
      const targetH=H, targetW=targetH*ratio;
      ctx.drawImage(mannequin,0,0,targetW,targetH);
    }

    // レーン
    ctx.fillStyle="rgba(150,180,255,0.25)"; ctx.fillRect(0,mouthY-20,W,40);
    ctx.fillStyle="rgba(255,180,180,0.25)"; ctx.fillRect(0,chestY-20,W,40);

    // 判定円
    ctx.lineWidth=4;
    ctx.strokeStyle="#1877ff"; ctx.beginPath(); ctx.arc(hitX,mouthY,30,0,2*Math.PI); ctx.stroke();
    ctx.strokeStyle="#ff4b4b"; ctx.beginPath(); ctx.arc(hitX,chestY,35,0,2*Math.PI); ctx.stroke();

    const right=W-40;
    const speed=(right-hitX)/lead;  // ★保存版の見た目速度を固定

    for(const n of chart){
      const x = hitX + (n.time - now)*speed;  // now < n.time → 右側（=右→左に流れる）
      if(x<-140 || x>W+140) continue;

      if(n.type==="comp"){
        ctx.fillStyle="#ff4b4b";
        ctx.beginPath(); ctx.arc(x,n.y,20,0,2*Math.PI); ctx.fill();
      }else{
        const xE = hitX + ((n.time+n.hold) - now)*speed;
        ctx.fillStyle="#1877ff";
        ctx.fillRect(Math.min(x,xE),n.y-10,Math.abs(xE-x),20);
        ctx.beginPath(); ctx.arc(x,n.y,10,0,2*Math.PI); ctx.fill();
        ctx.beginPath(); ctx.arc(xE,n.y,10,0,2*Math.PI); ctx.fill();
      }
    }

    // ハート＆閃光
    for(const h of hearts){
      ctx.globalAlpha=h.alpha; ctx.fillStyle="#ff8ccf";
      ctx.beginPath();
      ctx.moveTo(h.x,h.y);
      ctx.bezierCurveTo(h.x-6,h.y-8,h.x-14,h.y+2,h.x,h.y+12);
      ctx.bezierCurveTo(h.x+14,h.y+2,h.x+6,h.y-8,h.x,h.y);
      ctx.fill(); ctx.globalAlpha=1;
    }
    for(const f of flashes){
      ctx.globalAlpha=f.life; ctx.fillStyle=f.color;
      ctx.beginPath(); ctx.arc(f.x,f.y,25*(1-f.life),0,2*Math.PI); ctx.fill(); ctx.globalAlpha=1;
    }
    for(const h of hearts){ h.y+=h.vy; h.alpha-=0.02; }
    for(const f of flashes){ f.life-=0.05; }
    hearts=hearts.filter(h=>h.alpha>0);
    flashes=flashes.filter(f=>f.life>0);
  }

  // ===== ループ・結果 =====
  let goTime=null;
  function loop(){
    const now=AC?AC.currentTime:performance.now()/1000;
    draw(now);
    if(running && goTime){
      if(now>=goTime+STOP_AT || chart.every(n=>n.hit)){ running=false; showResult(); return; }
    }
    if(running) requestAnimationFrame(loop);
  }
  function showResult(){
    const total=chart.length;
    const score=Math.round((perfect*3+good*1)/(total*3)*100);
    resultPanel.innerHTML=`💖 SCORE ${score}点！<br>Perfect: ${perfect}　Good: ${good}　Miss: ${miss}`;
    resultPanel.style.opacity=1;
  }

  // ===== カウントダウン =====
  function runCountdown(onGo){
    const seq=["3","2","1","GO!"]; let i=0;
    countdownEl.style.opacity=1; countdownEl.textContent=seq[i++];
    const timer=setInterval(()=>{
      if(i<seq.length){ countdownEl.textContent=seq[i++]; }
      else { clearInterval(timer); setTimeout(()=>countdownEl.style.opacity=0,600); onGo(); }
    },1000);
  }

  // ===== 開始ボタン =====
  document.getElementById("start").onclick=async()=>{
    await ensureAudio(); click();
    perfect=good=miss=0; resultPanel.style.opacity=0; running=true;

    runCountdown(()=>{
      goTime=AC.currentTime;

      // ★ 到達時刻そのものを GO+ARRIVE_AT に揃える（保存版スピードのまま自然出現）
      const startBase = goTime + appearDelay;

      chart = chartTemplate.map(n=>({
        ...n,
        time: startBase + n.offset, // ここが「判定円に重なる絶対時刻」
        hold: n.hold||0,
        hit: false
      }));

      loop();
    });
  };
  document.getElementById("stop").onclick=()=>{ running=false; showResult(); };
  document.getElementById("reset").onclick=()=>window.location.reload();
})();
</script>
</body>
</html>
